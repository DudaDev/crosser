{"version":3,"sources":["webpack:///webpack/bootstrap 0c400da4f110b97343d3?7057","webpack:///./lib/crosser-with-rsvp.js","webpack:///./lib/modules/crosser/get-crosser-class.js?2713","webpack:///./lib/modules/promise/rsvp-promise.js","webpack:///./~/rsvp/dist/rsvp.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///(webpack)/buildin/module.js","webpack:///vertx (ignored)","webpack:///(webpack)/buildin/amd-define.js"],"names":[],"mappings":"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AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA,uDAAsD,6BAA6B;;AAEnF,mCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,wCAAuC,KAAK;AAC5C,yCAAwC,UAAU;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;;AAET,qCAAoC,gBAAgB;AACpD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA,6BAA4B;AAC5B;;AAEA,iCAAgC;;AAEhC;AACA;AACA,iCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAgC;;AAEhC;AACA,iCAAgC;AAChC;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4BAA2B,4BAA4B;AACvD,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET,gCAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,IAAI;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAuB,uCAAuC;AAC9D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,wBAAuB,QAAQ;AAC/B;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA2D,QAAQ;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,4DAA2D,QAAQ;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAqC,QAAQ;;AAE7C;;AAEA,sBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA,UAAS;AACT,0BAAyB,QAAQ;AACjC;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAqB,8DAA8D;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,8DAA8D;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA,eAAc,SAAS;AACvB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB,eAAc,OAAO;AACrB;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,eAAc,SAAS;AACvB,eAAc,OAAO;AACrB;AACA,gBAAe;AACf;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B;AAC5B,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA,eAAc,SAAS;AACvB,eAAc,OAAO;AACrB;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qEAAoE;;AAEpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,sBAAsB;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,wBAAwB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA;;AAEA,0BAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,8DAA8D;AACnF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,YAAY;AACnC;AACA;;AAEA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,YAAY;AACjC;AACA;;AAEA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,OAAO;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAyB,2BAA2B,EAAE;AACtD,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;;;;;;;;;ACroDD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACzFtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,G;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA,gB;;;;;;ACAA,8BAA6B,mDAAmD","file":"./crosser-with-rsvp.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0c400da4f110b97343d3\n **/","import Promise from './modules/promise/rsvp-promise';\nimport getCrosserClass from './modules/crosser/get-crosser-class';\n\nvar Crosser = getCrosserClass({\n\tPromise: Promise\n});\n\nif (window) {\n\twindow.Crosser = Crosser;\n}\n\nexport default Crosser;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./lib/crosser-with-rsvp.js\n **/","export default function(options){\n\tvar Promise = options.Promise;\n\n\tfunction generateId() {\n\t\treturn new Date().getTime().toString();\n\t}\n\n\tclass Crosser {\n\n\t\tconstructor(otherFrameWindow, origin) {\n\t\t\t/* private */\n\t\t\tthis._sessionHandlers = {};\n\t\t\tthis._listeners = {};\n\t\t\tthis._otherFrameWindow = otherFrameWindow;\n\t\t\tthis._otherOrigin = origin || '*';\n\t\t\tthis._id = generateId();\n\t\t\tthis._events = {};\n\n\t\t\tif (!this._otherFrameWindow || !this._otherFrameWindow.postMessage) {\n\t\t\t\tthrow new Error('Missing frame to communicate with');\n\t\t\t}\n\n\t\t\twindow.addEventListener(\"message\", this.receiveMessage.bind(this), false);\n\t\t}\n\n\t\treceiveMessage(event) {\n\t\t\tvar message = event.data,\n\t\t\t\tdoesOriginMatch = this.doesOriginMatch(event.origin);\n\n\t\t\tif (!doesOriginMatch || !message) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (message.type === 'event') {\n\t\t\t\tif (message.eventName && this._events[message.eventName]) {\n\t\t\t\t\tthis.fireEvent(event);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (message.sessionName &&\n\t\t\t\t\tthis._sessionHandlers[message.sessionName] &&\n\t\t\t\t\tmessage.creator === this._id) {\n\n\t\t\t\t\tthis.endSession(event);\n\t\t\t\t} else if (\n\t\t\t\t\tmessage.sessionName &&\n\t\t\t\t\tmessage.creator !== this._id) {\n\n\t\t\t\t\tthis.throwBackSession(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdoesOriginMatch(eventOrigin) {\n\t\t\tvar ret =\n\t\t\t\t(\n\t\t\t\t\teventOrigin === this._otherOrigin ||\n\t\t\t\t\t(\n\t\t\t\t\t\tthis._otherOrigin === '*' &&\n\t\t\t\t\t\twindow.location.origin === eventOrigin\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\treturn ret;\n\t\t}\n\n\t\tendSession(event) {\n\t\t\tvar message = event.data;\n\t\t\tvar resolve = this._sessionHandlers[message.sessionName].resolve;\n\t\t\tvar reject = this._sessionHandlers[message.sessionName].reject;\n\n\t\t\tthis.deleteSession(message.sessionName);\n\n\t\t\tif (message.error) {\n\t\t\t\treject(message.error);\n\t\t\t} else {\n\t\t\t\tresolve(message.payload);\n\t\t\t}\n\t\t}\n\n\t\tthrowBackSession(event) {\n\t\t\tvar message = event.data,\n\t\t\t\tsessionName = message.sessionName;\n\n\t\t\tObject.keys(this._listeners[sessionName] || {}).forEach(function(subscriberId) {\n\t\t\t\tvar callbackResult = this._listeners[sessionName][subscriberId](message.payload);\n\t\t\t\tif (callbackResult && callbackResult.then) {\n\t\t\t\t\tcallbackResult.then(function(resolvedPayload) {\n\t\t\t\t\t\tthis.postMessage({\n\t\t\t\t\t\t\tsessionName: sessionName,\n\t\t\t\t\t\t\tpayload: resolvedPayload,\n\t\t\t\t\t\t\tcreator: message.creator\n\t\t\t\t\t\t});\n\t\t\t\t\t}.bind(this));\n\t\t\t\t} else {\n\t\t\t\t\tthis.postMessage({\n\t\t\t\t\t\tsessionName: sessionName,\n\t\t\t\t\t\tpayload: callbackResult,\n\t\t\t\t\t\tcreator: message.creator\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t}\n\n\t\tpostMessage(message) {\n\t\t\tthis._otherFrameWindow.postMessage(message, this._otherOrigin);\n\t\t}\n\n\t\tdeleteSession(sessionName) {\n\t\t\tthis._sessionHandlers[sessionName].resolve = null;\n\t\t\tdelete this._sessionHandlers[sessionName].resolve;\n\t\t\tthis._sessionHandlers[sessionName].reject = null;\n\t\t\tdelete this._sessionHandlers[sessionName].reject;\n\t\t\tthis._sessionHandlers[sessionName] = null;\n\t\t\tdelete this._sessionHandlers[sessionName];\n\t\t}\n\n\t\tdestroy() {\n\t\t\tObject.keys(this._listeners || {}).forEach(this.unsubscribe, this);\n\t\t\tObject.keys(this._sessionHandlers || {}).forEach(this.deleteSession, this);\n\t\t\tthis._otherFrameWindow = null;\n\t\t\tthis._otherOrigin = null;\n\t\t\tthis._id = null;\n\t\t}\n\n\t\ttrigger(sessionName, payload) {\n\t\t\tvar promise;\n\n\t\t\tif (this._sessionHandlers[sessionName]) {\n\t\t\t\tthrow new Error('A session with the name ' + sessionName + ' is still alive');\n\t\t\t}\n\n\t\t\tpromise = new Promise(function(resolve, reject) {\n\t\t\t\tthis._sessionHandlers[sessionName] = {\n\t\t\t\t\tresolve: resolve,\n\t\t\t\t\treject: reject\n\t\t\t\t};\n\t\t\t}.bind(this));\n\n\t\t\tthis.postMessage({\n\t\t\t\tsessionName: sessionName,\n\t\t\t\tpayload: payload,\n\t\t\t\tcreator: this._id\n\t\t\t});\n\n\t\t\treturn promise;\n\t\t}\n\n\t\tabort(sessionName) {\n\t\t\tthis.deleteSession(sessionName);\n\t\t}\n\n\t\tsubscribe(sessionName, callback) {\n\t\t\tvar subscriberId = generateId();\n\n\t\t\tthis._listeners[sessionName] = this._listeners[sessionName] || {};\n\t\t\tif (Object.keys(this._listeners[sessionName] || {}).length > 0) {\n\t\t\t\tthrow new Error('A session ( ' + sessionName + ' ) can have only one subscriber');\n\t\t\t}\n\n\t\t\tthis._listeners[sessionName][subscriberId] = callback;\n\t\t\treturn subscriberId;\n\t\t}\n\n\t\tunsubscribe(sessionName, subscriberId) {\n\t\t\tif (!subscriberId) {\n\t\t\t\tObject.keys(this._listeners[sessionName] || {}).forEach(this.unsubscribe.bind(this, sessionName));\n\t\t\t} else {\n\t\t\t\tthis._listeners[sessionName][subscriberId] = null;\n\t\t\t\tdelete this._listeners[sessionName][subscriberId];\n\t\t\t}\n\t\t}\n\n\t\tfireEvent(event) {\n\t\t\tvar message = event.data;\n\n\t\t\tthis._events[message.eventName].forEach(function(callback) {\n\t\t\t\tcallback(message.payload);\n\t\t\t});\n\t\t}\n\n\t\tsubscribeEvent(eventName, callback) {\n\t\t\tthis._events[eventName] = this._events[eventName] || [];\n\t\t\tthis._events[eventName].push(callback);\n\t\t}\n\n\t\tunsubscribeEvent(eventName) {\n\t\t\tthis._events[eventName] = null;\n\t\t\tdelete this._events[eventName];\n\t\t}\n\n\t\ttriggerEvent(eventName, payload) {\n\t\t\tthis.postMessage({\n\t\t\t\teventName: eventName,\n\t\t\t\ttype: 'event',\n\t\t\t\tpayload: payload,\n\t\t\t\tcreator: this._id\n\t\t\t});\n\t\t}\n\t}\n\n\treturn Crosser;\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./lib/modules/crosser/get-crosser-class.js\n **/","import {\n\tPromise\n}\nfrom 'rsvp';\n\nexport default Promise;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./lib/modules/promise/rsvp-promise.js\n **/","/*!\n * @overview RSVP - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n * @version   3.0.18\n */\n\n(function() {\n    \"use strict\";\n    function lib$rsvp$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$rsvp$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$rsvp$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$rsvp$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$rsvp$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$rsvp$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;\n\n    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };\n\n    function lib$rsvp$utils$$F() { }\n\n    var lib$rsvp$utils$$o_create = (Object.create || function (o) {\n      if (arguments.length > 1) {\n        throw new Error('Second argument not supported');\n      }\n      if (typeof o !== 'object') {\n        throw new TypeError('Argument must be an object');\n      }\n      lib$rsvp$utils$$F.prototype = o;\n      return new lib$rsvp$utils$$F();\n    });\n    function lib$rsvp$events$$indexOf(callbacks, callback) {\n      for (var i=0, l=callbacks.length; i<l; i++) {\n        if (callbacks[i] === callback) { return i; }\n      }\n\n      return -1;\n    }\n\n    function lib$rsvp$events$$callbacksFor(object) {\n      var callbacks = object._promiseCallbacks;\n\n      if (!callbacks) {\n        callbacks = object._promiseCallbacks = {};\n      }\n\n      return callbacks;\n    }\n\n    var lib$rsvp$events$$default = {\n\n      /**\n        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For\n        Example:\n\n        ```javascript\n        var object = {};\n\n        RSVP.EventTarget.mixin(object);\n\n        object.on('finished', function(event) {\n          // handle event\n        });\n\n        object.trigger('finished', { detail: value });\n        ```\n\n        `EventTarget.mixin` also works with prototypes:\n\n        ```javascript\n        var Person = function() {};\n        RSVP.EventTarget.mixin(Person.prototype);\n\n        var yehuda = new Person();\n        var tom = new Person();\n\n        yehuda.on('poke', function(event) {\n          console.log('Yehuda says OW');\n        });\n\n        tom.on('poke', function(event) {\n          console.log('Tom says OW');\n        });\n\n        yehuda.trigger('poke');\n        tom.trigger('poke');\n        ```\n\n        @method mixin\n        @for RSVP.EventTarget\n        @private\n        @param {Object} object object to extend with EventTarget methods\n      */\n      'mixin': function(object) {\n        object['on']      = this['on'];\n        object['off']     = this['off'];\n        object['trigger'] = this['trigger'];\n        object._promiseCallbacks = undefined;\n        return object;\n      },\n\n      /**\n        Registers a callback to be executed when `eventName` is triggered\n\n        ```javascript\n        object.on('event', function(eventInfo){\n          // handle the event\n        });\n\n        object.trigger('event');\n        ```\n\n        @method on\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to listen for\n        @param {Function} callback function to be called when the event is triggered.\n      */\n      'on': function(eventName, callback) {\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;\n\n        callbacks = allCallbacks[eventName];\n\n        if (!callbacks) {\n          callbacks = allCallbacks[eventName] = [];\n        }\n\n        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {\n          callbacks.push(callback);\n        }\n      },\n\n      /**\n        You can use `off` to stop firing a particular callback for an event:\n\n        ```javascript\n        function doStuff() { // do stuff! }\n        object.on('stuff', doStuff);\n\n        object.trigger('stuff'); // doStuff will be called\n\n        // Unregister ONLY the doStuff callback\n        object.off('stuff', doStuff);\n        object.trigger('stuff'); // doStuff will NOT be called\n        ```\n\n        If you don't pass a `callback` argument to `off`, ALL callbacks for the\n        event will not be executed when the event fires. For example:\n\n        ```javascript\n        var callback1 = function(){};\n        var callback2 = function(){};\n\n        object.on('stuff', callback1);\n        object.on('stuff', callback2);\n\n        object.trigger('stuff'); // callback1 and callback2 will be executed.\n\n        object.off('stuff');\n        object.trigger('stuff'); // callback1 and callback2 will not be executed!\n        ```\n\n        @method off\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName event to stop listening to\n        @param {Function} callback optional argument. If given, only the function\n        given will be removed from the event's callback queue. If no `callback`\n        argument is given, all callbacks will be removed from the event's callback\n        queue.\n      */\n      'off': function(eventName, callback) {\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;\n\n        if (!callback) {\n          allCallbacks[eventName] = [];\n          return;\n        }\n\n        callbacks = allCallbacks[eventName];\n\n        index = lib$rsvp$events$$indexOf(callbacks, callback);\n\n        if (index !== -1) { callbacks.splice(index, 1); }\n      },\n\n      /**\n        Use `trigger` to fire custom events. For example:\n\n        ```javascript\n        object.on('foo', function(){\n          console.log('foo event happened!');\n        });\n        object.trigger('foo');\n        // 'foo event happened!' logged to the console\n        ```\n\n        You can also pass a value as a second argument to `trigger` that will be\n        passed as an argument to all event listeners for the event:\n\n        ```javascript\n        object.on('foo', function(value){\n          console.log(value.name);\n        });\n\n        object.trigger('foo', { name: 'bar' });\n        // 'bar' logged to the console\n        ```\n\n        @method trigger\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to be triggered\n        @param {Any} options optional value to be passed to any event handlers for\n        the given `eventName`\n      */\n      'trigger': function(eventName, options) {\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;\n\n        if (callbacks = allCallbacks[eventName]) {\n          // Don't cache the callbacks.length since it may grow\n          for (var i=0; i<callbacks.length; i++) {\n            callback = callbacks[i];\n\n            callback(options);\n          }\n        }\n      }\n    };\n\n    var lib$rsvp$config$$config = {\n      instrument: false\n    };\n\n    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);\n\n    function lib$rsvp$config$$configure(name, value) {\n      if (name === 'onerror') {\n        // handle for legacy users that expect the actual\n        // error to be passed to their function added via\n        // `RSVP.configure('onerror', someFunctionHere);`\n        lib$rsvp$config$$config['on']('error', value);\n        return;\n      }\n\n      if (arguments.length === 2) {\n        lib$rsvp$config$$config[name] = value;\n      } else {\n        return lib$rsvp$config$$config[name];\n      }\n    }\n\n    var lib$rsvp$instrument$$queue = [];\n\n    function lib$rsvp$instrument$$scheduleFlush() {\n      setTimeout(function() {\n        var entry;\n        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {\n          entry = lib$rsvp$instrument$$queue[i];\n\n          var payload = entry.payload;\n\n          payload.guid = payload.key + payload.id;\n          payload.childGuid = payload.key + payload.childId;\n          if (payload.error) {\n            payload.stack = payload.error.stack;\n          }\n\n          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);\n        }\n        lib$rsvp$instrument$$queue.length = 0;\n      }, 50);\n    }\n\n    function lib$rsvp$instrument$$instrument(eventName, promise, child) {\n      if (1 === lib$rsvp$instrument$$queue.push({\n          name: eventName,\n          payload: {\n            key: promise._guidKey,\n            id:  promise._id,\n            eventName: eventName,\n            detail: promise._result,\n            childId: child && child._id,\n            label: promise._label,\n            timeStamp: lib$rsvp$utils$$now(),\n            error: lib$rsvp$config$$config[\"instrument-with-stack\"] ? new Error(promise._label) : null\n          }})) {\n            lib$rsvp$instrument$$scheduleFlush();\n          }\n      }\n    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;\n\n    function  lib$rsvp$$internal$$withOwnPromise() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$rsvp$$internal$$noop() {}\n\n    var lib$rsvp$$internal$$PENDING   = void 0;\n    var lib$rsvp$$internal$$FULFILLED = 1;\n    var lib$rsvp$$internal$$REJECTED  = 2;\n\n    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n    function lib$rsvp$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;\n        return lib$rsvp$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {\n      lib$rsvp$config$$config.async(function(promise) {\n        var sealed = false;\n        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$rsvp$$internal$$resolve(promise, value);\n          } else {\n            lib$rsvp$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$rsvp$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$rsvp$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {\n        lib$rsvp$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {\n        thenable._onError = null;\n        lib$rsvp$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {\n          if (thenable !== value) {\n            lib$rsvp$$internal$$resolve(promise, value);\n          } else {\n            lib$rsvp$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          lib$rsvp$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$rsvp$$internal$$getThen(maybeThenable);\n\n        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {\n          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$rsvp$utils$$isFunction(then)) {\n          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$rsvp$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      } else if (lib$rsvp$utils$$objectOrFunction(value)) {\n        lib$rsvp$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$rsvp$$internal$$publishRejection(promise) {\n      if (promise._onError) {\n        promise._onError(promise._result);\n      }\n\n      lib$rsvp$$internal$$publish(promise);\n    }\n\n    function lib$rsvp$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$rsvp$$internal$$FULFILLED;\n\n      if (promise._subscribers.length === 0) {\n        if (lib$rsvp$config$$config.instrument) {\n          lib$rsvp$instrument$$default('fulfilled', promise);\n        }\n      } else {\n        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);\n      }\n    }\n\n    function lib$rsvp$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n      promise._state = lib$rsvp$$internal$$REJECTED;\n      promise._result = reason;\n      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);\n    }\n\n    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onError = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);\n      }\n    }\n\n    function lib$rsvp$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);\n      }\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$rsvp$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n    function lib$rsvp$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$rsvp$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$rsvp$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$rsvp$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$rsvp$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$rsvp$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$rsvp$$internal$$reject(promise, error);\n      } else if (settled === lib$rsvp$$internal$$FULFILLED) {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      } else if (settled === lib$rsvp$$internal$$REJECTED) {\n        lib$rsvp$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$rsvp$$internal$$initializePromise(promise, resolver) {\n      var resolved = false;\n      try {\n        resolver(function resolvePromise(value){\n          if (resolved) { return; }\n          resolved = true;\n          lib$rsvp$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          if (resolved) { return; }\n          resolved = true;\n          lib$rsvp$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$rsvp$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {\n      if (state === lib$rsvp$$internal$$FULFILLED) {\n        return {\n          state: 'fulfilled',\n          value: value\n        };\n      } else {\n        return {\n          state: 'rejected',\n          reason: value\n        };\n      }\n    }\n\n    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      this._abortOnReject = abortOnReject;\n\n      if (this._validateInput(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._init();\n\n        if (this.length === 0) {\n          lib$rsvp$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            lib$rsvp$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        lib$rsvp$$internal$$reject(this.promise, this._validationError());\n      }\n    }\n\n    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;\n\n    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$rsvp$utils$$isArray(input);\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var promise = this.promise;\n      var input   = this._input;\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      if (lib$rsvp$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {\n          entry._onError = null;\n          this._settledAt(entry._state, i, entry._result);\n        } else {\n          this._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        this._remaining--;\n        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === lib$rsvp$$internal$$PENDING) {\n        this._remaining--;\n\n        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {\n          lib$rsvp$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = this._makeResult(state, i, value);\n        }\n      }\n\n      if (this._remaining === 0) {\n        lib$rsvp$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n      return value;\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$rsvp$promise$all$$all(entries, label) {\n      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n    }\n    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;\n    function lib$rsvp$promise$race$$race(entries, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\n      if (!lib$rsvp$utils$$isArray(entries)) {\n        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$rsvp$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$rsvp$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;\n    function lib$rsvp$promise$resolve$$resolve(object, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      lib$rsvp$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;\n    function lib$rsvp$promise$reject$$reject(reason, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      lib$rsvp$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;\n\n    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';\n    var lib$rsvp$promise$$counter = 0;\n\n    function lib$rsvp$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$rsvp$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promiseâ€™s eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class RSVP.Promise\n      @param {function} resolver\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @constructor\n    */\n    function lib$rsvp$promise$$Promise(resolver, label) {\n      this._id = lib$rsvp$promise$$counter++;\n      this._label = label;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default('created', this);\n      }\n\n      if (lib$rsvp$$internal$$noop !== resolver) {\n        if (!lib$rsvp$utils$$isFunction(resolver)) {\n          lib$rsvp$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$rsvp$promise$$Promise)) {\n          lib$rsvp$promise$$needsNew();\n        }\n\n        lib$rsvp$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;\n\n    // deprecated\n    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;\n    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;\n    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;\n    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;\n    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;\n\n    lib$rsvp$promise$$Promise.prototype = {\n      constructor: lib$rsvp$promise$$Promise,\n\n      _guidKey: lib$rsvp$promise$$guidKey,\n\n      _onError: function (reason) {\n        lib$rsvp$config$$config.async(function(promise) {\n          setTimeout(function() {\n            if (promise._onError) {\n              lib$rsvp$config$$config['trigger']('error', reason);\n            }\n          }, 0);\n        }, this);\n      },\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection, label) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {\n          if (lib$rsvp$config$$config.instrument) {\n            lib$rsvp$instrument$$default('chained', this, this);\n          }\n          return this;\n        }\n\n        parent._onError = null;\n\n        var child = new this.constructor(lib$rsvp$$internal$$noop, label);\n        var result = parent._result;\n\n        if (lib$rsvp$config$$config.instrument) {\n          lib$rsvp$instrument$$default('chained', parent, child);\n        }\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$rsvp$config$$config.async(function(){\n            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection, label) {\n        return this.then(null, onRejection, label);\n      },\n\n    /**\n      `finally` will be invoked regardless of the promise's fate just as native\n      try/catch/finally behaves\n\n      Synchronous example:\n\n      ```js\n      findAuthor() {\n        if (Math.random() > 0.5) {\n          throw new Error();\n        }\n        return new Author();\n      }\n\n      try {\n        return findAuthor(); // succeed or fail\n      } catch(error) {\n        return findOtherAuther();\n      } finally {\n        // always runs\n        // doesn't affect the return value\n      }\n      ```\n\n      Asynchronous example:\n\n      ```js\n      findAuthor().catch(function(reason){\n        return findOtherAuther();\n      }).finally(function(){\n        // author was either found, or not\n      });\n      ```\n\n      @method finally\n      @param {Function} callback\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'finally': function(callback, label) {\n        var constructor = this.constructor;\n\n        return this.then(function(value) {\n          return constructor.resolve(callback()).then(function(){\n            return value;\n          });\n        }, function(reason) {\n          return constructor.resolve(callback()).then(function(){\n            throw reason;\n          });\n        }, label);\n      }\n    };\n\n    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {\n      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);\n    }\n\n    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {\n      return new Error('allSettled must be called with an array');\n    };\n\n    function lib$rsvp$all$settled$$allSettled(entries, label) {\n      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;\n    }\n    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;\n    function lib$rsvp$all$$all(array, label) {\n      return lib$rsvp$promise$$default.all(array, label);\n    }\n    var lib$rsvp$all$$default = lib$rsvp$all$$all;\n    var lib$rsvp$asap$$len = 0;\n    var lib$rsvp$asap$$toString = {}.toString;\n    var lib$rsvp$asap$$vertxNext;\n    function lib$rsvp$asap$$asap(callback, arg) {\n      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;\n      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;\n      lib$rsvp$asap$$len += 2;\n      if (lib$rsvp$asap$$len === 2) {\n        // If len is 1, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        lib$rsvp$asap$$scheduleFlush();\n      }\n    }\n\n    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;\n\n    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};\n    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$rsvp$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$rsvp$asap$$useNextTick() {\n      var nextTick = process.nextTick;\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // setImmediate should be used instead instead\n      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n        nextTick = setImmediate;\n      }\n      return function() {\n        nextTick(lib$rsvp$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$rsvp$asap$$useVertxTimer() {\n      return function() {\n        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);\n      };\n    }\n\n    function lib$rsvp$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$rsvp$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$rsvp$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$rsvp$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$rsvp$asap$$flush, 1);\n      };\n    }\n\n    var lib$rsvp$asap$$queue = new Array(1000);\n    function lib$rsvp$asap$$flush() {\n      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {\n        var callback = lib$rsvp$asap$$queue[i];\n        var arg = lib$rsvp$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$rsvp$asap$$queue[i] = undefined;\n        lib$rsvp$asap$$queue[i+1] = undefined;\n      }\n\n      lib$rsvp$asap$$len = 0;\n    }\n\n    function lib$rsvp$asap$$attemptVertex() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$rsvp$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$rsvp$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$rsvp$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$rsvp$asap$$isNode) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();\n    } else if (lib$rsvp$asap$$BrowserMutationObserver) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();\n    } else if (lib$rsvp$asap$$isWorker) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();\n    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();\n    } else {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();\n    }\n    function lib$rsvp$defer$$defer(label) {\n      var deferred = { };\n\n      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {\n        deferred['resolve'] = resolve;\n        deferred['reject'] = reject;\n      }, label);\n\n      return deferred;\n    }\n    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;\n    function lib$rsvp$filter$$filter(promises, filterFn, label) {\n      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!lib$rsvp$utils$$isFunction(filterFn)) {\n          throw new TypeError(\"You must pass a function as filter's second argument.\");\n        }\n\n        var length = values.length;\n        var filtered = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          filtered[i] = filterFn(values[i]);\n        }\n\n        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {\n          var results = new Array(length);\n          var newLength = 0;\n\n          for (var i = 0; i < length; i++) {\n            if (filtered[i]) {\n              results[newLength] = values[i];\n              newLength++;\n            }\n          }\n\n          results.length = newLength;\n\n          return results;\n        });\n      });\n    }\n    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;\n\n    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {\n      this._superConstructor(Constructor, object, true, label);\n    }\n\n    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {\n      this._result = {};\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {\n      return input && typeof input === 'object';\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {\n      return new Error('Promise.hash must be called with an object');\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {\n      var promise = this.promise;\n      var input   = this._input;\n      var results = [];\n\n      for (var key in input) {\n        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {\n          results.push({\n            position: key,\n            entry: input[key]\n          });\n        }\n      }\n\n      var length = results.length;\n      this._remaining = length;\n      var result;\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        result = results[i];\n        this._eachEntry(result.entry, result.position);\n      }\n    };\n\n    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {\n      this._superConstructor(Constructor, object, false, label);\n    }\n\n    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);\n    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\n    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {\n      return new Error('hashSettled must be called with an object');\n    };\n\n    function lib$rsvp$hash$settled$$hashSettled(object, label) {\n      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;\n    }\n    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;\n    function lib$rsvp$hash$$hash(object, label) {\n      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;\n    }\n    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;\n    function lib$rsvp$map$$map(promises, mapFn, label) {\n      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!lib$rsvp$utils$$isFunction(mapFn)) {\n          throw new TypeError(\"You must pass a function as map's second argument.\");\n        }\n\n        var length = values.length;\n        var results = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          results[i] = mapFn(values[i]);\n        }\n\n        return lib$rsvp$promise$$default.all(results, label);\n      });\n    }\n    var lib$rsvp$map$$default = lib$rsvp$map$$map;\n\n    function lib$rsvp$node$$Result() {\n      this.value = undefined;\n    }\n\n    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();\n    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();\n\n    function lib$rsvp$node$$getThen(obj) {\n      try {\n       return obj.then;\n      } catch(error) {\n        lib$rsvp$node$$ERROR.value= error;\n        return lib$rsvp$node$$ERROR;\n      }\n    }\n\n\n    function lib$rsvp$node$$tryApply(f, s, a) {\n      try {\n        f.apply(s, a);\n      } catch(error) {\n        lib$rsvp$node$$ERROR.value = error;\n        return lib$rsvp$node$$ERROR;\n      }\n    }\n\n    function lib$rsvp$node$$makeObject(_, argumentNames) {\n      var obj = {};\n      var name;\n      var i;\n      var length = _.length;\n      var args = new Array(length);\n\n      for (var x = 0; x < length; x++) {\n        args[x] = _[x];\n      }\n\n      for (i = 0; i < argumentNames.length; i++) {\n        name = argumentNames[i];\n        obj[name] = args[i + 1];\n      }\n\n      return obj;\n    }\n\n    function lib$rsvp$node$$arrayResult(_) {\n      var length = _.length;\n      var args = new Array(length - 1);\n\n      for (var i = 1; i < length; i++) {\n        args[i - 1] = _[i];\n      }\n\n      return args;\n    }\n\n    function lib$rsvp$node$$wrapThenable(then, promise) {\n      return {\n        then: function(onFulFillment, onRejection) {\n          return then.call(promise, onFulFillment, onRejection);\n        }\n      };\n    }\n\n    function lib$rsvp$node$$denodeify(nodeFunc, options) {\n      var fn = function() {\n        var self = this;\n        var l = arguments.length;\n        var args = new Array(l + 1);\n        var arg;\n        var promiseInput = false;\n\n        for (var i = 0; i < l; ++i) {\n          arg = arguments[i];\n\n          if (!promiseInput) {\n            // TODO: clean this up\n            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);\n            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {\n              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);\n              return p;\n            } else if (promiseInput && promiseInput !== true) {\n              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);\n            }\n          }\n          args[i] = arg;\n        }\n\n        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n\n        args[l] = function(err, val) {\n          if (err)\n            lib$rsvp$$internal$$reject(promise, err);\n          else if (options === undefined)\n            lib$rsvp$$internal$$resolve(promise, val);\n          else if (options === true)\n            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));\n          else if (lib$rsvp$utils$$isArray(options))\n            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));\n          else\n            lib$rsvp$$internal$$resolve(promise, val);\n        };\n\n        if (promiseInput) {\n          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);\n        } else {\n          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);\n        }\n      };\n\n      fn.__proto__ = nodeFunc;\n\n      return fn;\n    }\n\n    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;\n\n    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {\n      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n      if (result === lib$rsvp$node$$ERROR) {\n        lib$rsvp$$internal$$reject(promise, result.value);\n      }\n      return promise;\n    }\n\n    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){\n      return lib$rsvp$promise$$default.all(args).then(function(args){\n        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n        if (result === lib$rsvp$node$$ERROR) {\n          lib$rsvp$$internal$$reject(promise, result.value);\n        }\n        return promise;\n      });\n    }\n\n    function lib$rsvp$node$$needsPromiseInput(arg) {\n      if (arg && typeof arg === 'object') {\n        if (arg.constructor === lib$rsvp$promise$$default) {\n          return true;\n        } else {\n          return lib$rsvp$node$$getThen(arg);\n        }\n      } else {\n        return false;\n      }\n    }\n    function lib$rsvp$race$$race(array, label) {\n      return lib$rsvp$promise$$default.race(array, label);\n    }\n    var lib$rsvp$race$$default = lib$rsvp$race$$race;\n    function lib$rsvp$reject$$reject(reason, label) {\n      return lib$rsvp$promise$$default.reject(reason, label);\n    }\n    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;\n    function lib$rsvp$resolve$$resolve(value, label) {\n      return lib$rsvp$promise$$default.resolve(value, label);\n    }\n    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;\n    function lib$rsvp$rethrow$$rethrow(reason) {\n      setTimeout(function() {\n        throw reason;\n      });\n      throw reason;\n    }\n    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;\n\n    // default async is asap;\n    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;\n    var lib$rsvp$$cast = lib$rsvp$resolve$$default;\n    function lib$rsvp$$async(callback, arg) {\n      lib$rsvp$config$$config.async(callback, arg);\n    }\n\n    function lib$rsvp$$on() {\n      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);\n    }\n\n    function lib$rsvp$$off() {\n      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);\n    }\n\n    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`\n    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {\n      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];\n      lib$rsvp$config$$configure('instrument', true);\n      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {\n        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {\n          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);\n        }\n      }\n    }\n\n    var lib$rsvp$umd$$RSVP = {\n      'race': lib$rsvp$race$$default,\n      'Promise': lib$rsvp$promise$$default,\n      'allSettled': lib$rsvp$all$settled$$default,\n      'hash': lib$rsvp$hash$$default,\n      'hashSettled': lib$rsvp$hash$settled$$default,\n      'denodeify': lib$rsvp$node$$default,\n      'on': lib$rsvp$$on,\n      'off': lib$rsvp$$off,\n      'map': lib$rsvp$map$$default,\n      'filter': lib$rsvp$filter$$default,\n      'resolve': lib$rsvp$resolve$$default,\n      'reject': lib$rsvp$reject$$default,\n      'all': lib$rsvp$all$$default,\n      'rethrow': lib$rsvp$rethrow$$default,\n      'defer': lib$rsvp$defer$$default,\n      'EventTarget': lib$rsvp$events$$default,\n      'configure': lib$rsvp$config$$configure,\n      'async': lib$rsvp$$async\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$rsvp$umd$$RSVP; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$rsvp$umd$$RSVP;\n    } else if (typeof this !== 'undefined') {\n      this['RSVP'] = lib$rsvp$umd$$RSVP;\n    }\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rsvp/dist/rsvp.js\n ** module id = 4\n ** module chunks = 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 5\n ** module chunks = 1\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 6\n ** module chunks = 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 7\n ** module chunks = 1\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** vertx (ignored)\n ** module id = 8\n ** module chunks = 1\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 9\n ** module chunks = 1\n **/"],"sourceRoot":""}